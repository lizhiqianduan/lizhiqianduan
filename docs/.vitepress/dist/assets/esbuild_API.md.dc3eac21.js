import{_ as s,c as a,o as n,d as o}from"./app.b9288d32.js";const A=JSON.parse('{"title":"API | esbuild 中文文档","description":"","frontmatter":{"title":"API | esbuild 中文文档"},"headers":[{"level":2,"title":"Build","slug":"build","link":"#build","children":[]},{"level":2,"title":"Transform","slug":"transform","link":"#transform","children":[]},{"level":2,"title":"JS API的特殊细节（JS-specific details）","slug":"js-api的特殊细节-js-specific-details","link":"#js-api的特殊细节-js-specific-details","children":[]},{"level":2,"title":"在浏览器中使用（In the browser）","slug":"在浏览器中使用-in-the-browser","link":"#在浏览器中使用-in-the-browser","children":[]},{"level":2,"title":"简单选项","slug":"简单选项","link":"#简单选项","children":[{"level":3,"title":"别名 Alias","slug":"别名-alias","link":"#别名-alias","children":[]},{"level":3,"title":"报告 Analyze","slug":"报告-analyze","link":"#报告-analyze","children":[]},{"level":3,"title":"打包 Bundle","slug":"打包-bundle","link":"#打包-bundle","children":[]},{"level":3,"title":"预定义 Define","slug":"预定义-define","link":"#预定义-define","children":[]},{"level":3,"title":"入口点 Entry points","slug":"入口点-entry-points","link":"#入口点-entry-points","children":[]},{"level":3,"title":"外部包 External","slug":"外部包-external","link":"#外部包-external","children":[]},{"level":3,"title":"输出格式 Format","slug":"输出格式-format","link":"#输出格式-format","children":[]},{"level":3,"title":"注入 Inject","slug":"注入-inject","link":"#注入-inject","children":[]},{"level":3,"title":"加载器 Loader","slug":"加载器-loader","link":"#加载器-loader","children":[]},{"level":3,"title":"代码压缩 Minify","slug":"代码压缩-minify","link":"#代码压缩-minify","children":[]},{"level":3,"title":"输出目录 Outdir","slug":"输出目录-outdir","link":"#输出目录-outdir","children":[]},{"level":3,"title":"输出文件 Outfile","slug":"输出文件-outfile","link":"#输出文件-outfile","children":[]},{"level":3,"title":"依赖包 Packages","slug":"依赖包-packages","link":"#依赖包-packages","children":[]},{"level":3,"title":"平台 Platform","slug":"平台-platform","link":"#平台-platform","children":[]}]}],"relativePath":"esbuild/API.md","lastUpdated":1673515231000}'),l={name:"esbuild/API.md"},e=o(`<h1 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-hidden="true">#</a></h1><p>可以通过以下三种方式访问API：命令行、<code>JavaScript</code>和<code>Go</code>。这三种语言的概念和参数在很大程度上是相同的，因此它们将在这里一起呈现，而不是为每种语言提供单独的文档。</p><p><strong>CLI</strong>：如果您使用的是命令行API，了解这些标志的形式可能会有所帮助：<code>--foo</code>、<code>--foo=bar</code>或<code>--foo:bar</code>。形式<code>--foo</code>用于启用布尔标志（如<code>--minify</code>），形式<code>--foo=bar</code>用于具有单个值且仅指定一次的标志（如<code>--platform=</code>），而形式<code>--foo:bar</code>用于具有多个值且可以多次重新指定的标志（例如<code>--external:</code>）。</p><p><strong>JavaScript</strong>：如果您正在使用<code>JavaScript</code>，请务必查看下面的<code>JS API特殊细节</code>信息部分。您还可以找到<code>esbuild</code>的<code>TypeScript</code>类型定义作为参考。如果您正在使用Go，请务必查看自动生成的Go文档。</p><p><strong>Go</strong>：如果您正在使用Go，您可能会发现为esbuild自动生成的Go文档作为参考很有用。这两个公共Go软件包都有单独的文档：<code>pkg/api</code>和<code>pkg/cli</code>。</p><h1 id="概述-overview" tabindex="-1">概述 Overview <a class="header-anchor" href="#概述-overview" aria-hidden="true">#</a></h1><p><code>esbuild</code>的API中有两个主要的<code>API</code>调用：<code>transform</code>和<code>build</code>。你应该使用哪一种很重要，您应该了解清楚，因为它们的工作方式不同。</p><h2 id="build" tabindex="-1">Build <a class="header-anchor" href="#build" aria-hidden="true">#</a></h2><p>这是esbuild的主要接口。通常会传递一个或多个入口点文件和各种选项进行处理，然后esbuild将结果写回文件系统。下面是一个简单的示例，它支持与输出目录绑定：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.ts--bundle--outdir=dist</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>构建API的高级使用涉及设置长时间运行的构建上下文。此上下文在JS和Go中是一个显式对象，但在CLI中是隐式的。使用给定上下文完成的所有构建都共享相同的构建选项，并且后续构建是增量完成的（即，它们重用以前构建的一些工作以提高性能）。这对开发很有用，因为esbuild可以在您工作时在后台为您重建应用程序。</p><p>有三种不同形式的增量构建API：</p><ul><li><code>监视模式（Watch mode）</code>告诉<code>esbuild</code>监视文件系统，并在您编辑和保存可能使生成无效的文件时自动为您重新生成。以下是一个示例：</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">app.ts</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--bundle</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--outdir=dist</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--watch</span></span>
<span class="line"><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">watch</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> build finished, watching </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> changes...</span></span>
<span class="line"></span></code></pre></div><ul><li><code>服务模式（Serve mode）</code>会启动一个本地开发服务器，该服务器提供最新构建的结果。传入的请求会自动启动新的构建，因此当您在浏览器中重新加载页面时，您的web应用程序始终是最新的。以下是一个示例：</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">app.ts</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--bundle</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--outdir=dist</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--serve</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Local:</span><span style="color:#A6ACCD;">   </span><span style="color:#C3E88D;">http://127.0.0.1:</span><span style="color:#F78C6C;">8000</span><span style="color:#C3E88D;">/</span></span>
<span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Network:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">http://192.168.0.1:</span><span style="color:#F78C6C;">8000</span><span style="color:#C3E88D;">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">127.0.0.1:</span><span style="color:#F78C6C;">61302</span><span style="color:#A6ACCD;"> -</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">GET /</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">1ms</span><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><ul><li><code>重构建模式（rebuild mode）</code>允许你可以手动调用构建。这在将esbuild与其他工具集成时非常有用（例如，使用自定义文件观察程序或开发服务器，而不是esbuild的内置服务器）。以下是一个示例：</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> ctx </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">context</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">entryPoints</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">app.ts</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">bundle</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">outdir</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">dist</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">rebuild</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>这三个增量构建API可以组合在一起。要启用实时重新加载（在编辑和保存文件时自动重新加载页面），您需要在同一上下文中启用监视和服务。</p><p>处理完上下文对象后，可以在上下文上调用<code>dispose（）</code>以等待现有构建完成，停止监视和/或服务模式，并释放资源。</p><h2 id="transform" tabindex="-1">Transform <a class="header-anchor" href="#transform" aria-hidden="true">#</a></h2><p><code>Transform API</code>能在不访问文件系统的情况下对单个字符串进行操作。这使得它非常适合在没有文件系统（如浏览器）或作为其他工具链的一部分。下面是一个简单的变换：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#82AAFF;">echo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">let x: number = 1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--loader=ts</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># let x = 1;</span></span>
<span class="line"></span></code></pre></div><p>对于某些场景来说，使用字符串而不是文件作为输入更符合人们感官。文件系统隔离有一定的优点（例如，在浏览器中工作，不受附近<code>package.json</code>文件的影响），也有一定的缺点（例如，不能与bundling或插件一起使用）。如果您的场景不适合<code>Transform API</code>，那么您应该使用更通用的<code>Build API</code>。</p><h2 id="js-api的特殊细节-js-specific-details" tabindex="-1">JS API的特殊细节（JS-specific details） <a class="header-anchor" href="#js-api的特殊细节-js-specific-details" aria-hidden="true">#</a></h2><p>适用于<code>esbuild</code>的<code>JS API</code>有异步和同步两种风格。推荐使用异步API，因为它适用于所有环境，而且速度更快、功能更强大。同步API只在<code>Nodejs</code>中工作，并且只能做某些事情，但有时在特定的情况下是必要的。详细说明：</p><p><strong>异步API（Async API）</strong></p><p>异步API使用promise作为返回结果。请注意，由于使用了<code>import</code>和顶级<code>await</code>关键字，您可能不得不在<code>node</code>中使用<code>.mjs</code>文件扩展名：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> esbuild </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">esbuild</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">transform</span><span style="color:#A6ACCD;">(code</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> options)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">build</span><span style="color:#A6ACCD;">(options)</span></span>
<span class="line"></span></code></pre></div><p>优点：</p><ul><li><p>您可以使用带有异步API的插件</p></li><li><p>当前线程未被阻止，因此您可以在此期间执行其他工作</p></li><li><p>您可以同时运行多个<code>esbuild API</code>，然后将这些调用分布在所有可用的<code>CPU</code>中，以获得最大性能</p></li></ul><p>缺点：</p><ul><li><p>使用<code>promise</code>可能会导致代码更加混乱，尤其是在<code>CommonJS</code>中，顶级<code>await</code>不可用</p></li><li><p>在必须同步的情况下不起作用，例如在<code>require.extensions</code>中</p></li></ul><p><strong>同步API（Sync API）</strong></p><p>同步API的调用是直接在行内就返回结果了：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> esbuild </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">esbuild</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">transformSync</span><span style="color:#A6ACCD;">(code</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> options)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">buildSync</span><span style="color:#A6ACCD;">(options)</span></span>
<span class="line"></span></code></pre></div><p>优点：</p><ul><li><p>避免<code>promise</code>可能会有更干净的代码，尤其是在顶级<code>await</code>不可用的情况下</p></li><li><p>在必须同步的情况下工作，例如在<code>require.extensions</code>中</p></li></ul><p>缺点：</p><ul><li><p>您不能将插件与同步API一起使用，因为插件是异步的</p></li><li><p>它会阻塞当前线程，因此在此期间无法执行其他工作</p></li><li><p>使用同步API会阻止esbuild并行调用</p></li></ul><h2 id="在浏览器中使用-in-the-browser" tabindex="-1">在浏览器中使用（In the browser） <a class="header-anchor" href="#在浏览器中使用-in-the-browser" aria-hidden="true">#</a></h2><p><code>esbuild API</code>也可以使用<code>Web Worker</code>中的<code>WebAssembly</code>在浏览器中运行。要利用这一点，您需要安装<code>esbuild-wasm</code>包，而不是<code>esbuild</code>包：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">npm install esbuild-wasm</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>浏览器<code>API</code>类似于<code>Node</code>的<code>API</code>，只是您需要首先调用<code>initialize()</code>，并且需要传递<code>WebAssembly</code>二进制文件的<code>URL</code>。<code>API</code>的同步版本也不可用。假设你使用的是<code>bundler</code>，它看起来是这样的：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> esbuild </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">esbuild-wasm</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">initialize</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">wasmURL</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./node_modules/esbuild-wasm/esbuild.wasm</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">transform</span><span style="color:#A6ACCD;">(code</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> options)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> esbuild</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">build</span><span style="color:#A6ACCD;">(options)</span></span>
<span class="line"></span></code></pre></div><p>如果您已经从<code>worker</code>运行此代码，并且不希望<code>initialize</code>创建另一个工作线程，则可以将<code>worker:false</code>传递给它。然后它将在与调用<code>initialize</code>的线程相同的线程中创建<code>WebAssembly</code>模块。</p><p>您还可以在<code>HTML</code>文件中的<code>script</code>标签中使用<code>esbuild</code>的<code>API</code>，而无需通过加载带有<code>＜script＞</code>标记的<code>lib/browser.min.js</code>文件来使用打包工具。在这种情况下，<code>API</code>创建了一个名为<code>esbuild</code>的全局变量，该全局变量保存了<code>API</code>对象：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./node_modules/esbuild-wasm/lib/browser.min.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  esbuild.initialize(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    wasmURL: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./node_modules/esbuild-wasm/esbuild.wasm</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">).then(() =&gt; </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>如果要将此API与<code>ECMAScript</code>模块一起使用，则你应该导入<code>esm/browser.min.js</code>文件：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  import * as esbuild from &#39;./node_modules/esbuild-wasm/esm/browser.min.js&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  await esbuild.initialize(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    wasmURL: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./node_modules/esbuild-wasm/esbuild.wasm</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  // ...</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h2 id="简单选项" tabindex="-1">简单选项 <a class="header-anchor" href="#简单选项" aria-hidden="true">#</a></h2><h3 id="别名-alias" tabindex="-1">别名 Alias <a class="header-anchor" href="#别名-alias" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>此功能允许您在打包时用一个包替换另一个包。以下示例将包<code>oldpkg</code>替换为包<code>newpkg</code>：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">alias:oldpkg</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">newpkg</span></span>
<span class="line"></span></code></pre></div><p>这些替换首先会发生在<code>esbuild</code>所有的路径解析逻辑之前。此功能的一个使用场景是使用浏览器兼容包替换仅Node环境可使用的包，从而替换那些您无法控制的第三方代码，。</p><p>请注意，当使用<code>Alias</code>替换导入路径时，生成的导入路径将在工作目录中解析，而不是在包含具有导入路径的源文件的目录中解析。如果需要，可以使用<code>Working directory</code>功能设置<code>esbuild</code>所使用的工作目录。</p><h3 id="报告-analyze" tabindex="-1">报告 Analyze <a class="header-anchor" href="#报告-analyze" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p><em>如果您正在寻找交互式可视化，请尝试esbuild的Bundle Size Analyzer。您可以上传esbuild元文件以查看打包大小明细。</em></p><p>使用<code>Analyze</code>功能可以生成一份易于阅读的关于打包内容的报告：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--bundle</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--outfile=out.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--minify</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--analyze</span></span>
<span class="line"><span style="color:#FFCB6B;">out.js</span><span style="color:#A6ACCD;">                                                                    </span><span style="color:#C3E88D;">27.6kb</span><span style="color:#A6ACCD;">  </span><span style="color:#F78C6C;">100.0</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/cjs/react-dom-server.browser.production.min.js</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">19.2kb</span><span style="color:#A6ACCD;">   </span><span style="color:#F78C6C;">69.8</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react/cjs/react.production.min.js</span><span style="color:#A6ACCD;">                          </span><span style="color:#C3E88D;">5.9kb</span><span style="color:#A6ACCD;">   </span><span style="color:#F78C6C;">21.4</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/object-assign/index.js</span><span style="color:#A6ACCD;">                                     </span><span style="color:#C3E88D;">962b</span><span style="color:#A6ACCD;">     </span><span style="color:#F78C6C;">3.4</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span><span style="color:#A6ACCD;">                                                             </span><span style="color:#C3E88D;">137b</span><span style="color:#A6ACCD;">     </span><span style="color:#F78C6C;">0.5</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/server.browser.js</span><span style="color:#A6ACCD;">                                 </span><span style="color:#C3E88D;">50b</span><span style="color:#A6ACCD;">     </span><span style="color:#F78C6C;">0.2</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react/index.js</span><span style="color:#A6ACCD;">                                              </span><span style="color:#C3E88D;">50b</span><span style="color:#A6ACCD;">     </span><span style="color:#F78C6C;">0.2</span><span style="color:#C3E88D;">%</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">...</span></span>
<span class="line"></span></code></pre></div><p>该信息显示了每个<code>输出文件</code>打包的<code>输入文件</code>，以及它们最终占用的<code>输出文件</code>的百分比。如果您需要更多信息，可以启用<code>verbose</code>模式。这会显示从入口点到每个输入文件的导入路径，告诉您为什么给定的输入文件包含在打包文件中：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--bundle</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--outfile=out.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--minify</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--analyze=verbose</span></span>
<span class="line"><span style="color:#FFCB6B;">out.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">───────────────────────────────────────────────────────────────────</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">27.6kb</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">─</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100.0</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/cjs/react-dom-server.browser.production.min.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">─</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">19.2kb</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">──</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">69.8</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/server.browser.js</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react/cjs/react.production.min.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">─────────────────────────</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">5.9kb</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">──</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">21.4</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react/index.js</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/object-assign/index.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────────────────────────────────────</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">962b</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3.4</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/cjs/react-dom-server.browser.production.min.js</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">     </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/server.browser.js</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">        </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────────────────────────────────────────────────────────────</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">137b</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0.5</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">├</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react-dom/server.browser.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────────────────────────────────</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">50b</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0.2</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">│</span><span style="color:#A6ACCD;">  </span><span style="color:#C3E88D;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#FFCB6B;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">node_modules/react/index.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">─────────────────────────────────────────────</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">50b</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">────</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0.2</span><span style="color:#C3E88D;">%</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">└</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">example.jsx</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">...</span></span>
<span class="line"></span></code></pre></div><p>上述分析只包含<code>metafile</code>文件中可以找到的信息的可视化。如果此分析不完全符合您的需求，欢迎您使用<code>metafile</code>中的信息构建自己的可视化。</p><p>请注意，此格式化的分析结果适用于人类，而非机器。特定的格式可能会随着时间的推移而改变，这可能会破坏任何试图解析它的工具。您不应该编写工具来解析此数据。您应该使用<code>JSON</code>元数据文件中的信息。此可视化中的所有内容都源自<code>metafile</code>中的<code>JSON</code>元数据，这样您就不会因为不解析<code>esbuild</code>的格式化分析结果而丢失任何信息。</p><h3 id="打包-bundle" tabindex="-1">打包 Bundle <a class="header-anchor" href="#打包-bundle" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>打包文件意味着将任何导入的依赖项内联到文件本身中。此过程是递归的，因此依赖项的依赖项（等等）也将被内联。默认情况下，<code>esbuild</code>不会打包输入文件。打包必须显式启用，如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;">.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle</span></span>
<span class="line"></span></code></pre></div><p>请参阅入门指南，了解正式代码打包的示例。</p><p>请注意，打包不同于文件拼接。传递给<code>esbuild</code>多个需要打包的输入文件将生成多个单独的打包文件，而不是将输入文件拼接在一起。要使用<code>esbuild</code>将一组文件拼接在一起，请将它们全部导入到一个入口文件中，并将这个入口文件传递给<code>esuild</code>打包。</p><h4 id="不可解析的导入-non-analyzable-imports" tabindex="-1">不可解析的导入 Non-analyzable imports <a class="header-anchor" href="#不可解析的导入-non-analyzable-imports" aria-hidden="true">#</a></h4><p>使用<code>esbuild</code>打包仅适用于静态定义的导入（即，当导入路径是字符串文本时）。在运行时定义的导入（即依赖于运行时<code>run-time</code>代码求值的导入）不会被打包，因为打包是编译时<code>compile-time</code>操作。例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 可解析的导入 (将被esbuild打包)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pkg</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pkg</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pkg</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 不可解析的导入 (不会被esbuild打包)</span></span>
<span class="line"><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">pkg/</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">}\`</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">pkg/</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">}\`</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pkg</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(require)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>解决此问题的方法是将包含此问题代码的包标记为外部包<code>external</code>，以便它不包含在打包文件中。然后，您需要确保在运行时，打包后的代码可以访问到这个外部包的副本。</p><p>一些打包工具（如Webpack）试图通过在打包过程中包含所有可能访问到的文件，然后在运行时模拟文件系统来支持这一点。但是，运行时文件系统仿真超出了范围，不会在esbuild中实现。如果您确实需要打包时实现这一点，则可能需要使用另一个打包器而不是<code>esbuild</code>。</p><h3 id="预定义-define" tabindex="-1">预定义 Define <a class="header-anchor" href="#预定义-define" aria-hidden="true">#</a></h3><p><em>Supported by: Transform | Build</em></p><p>此功能提供了一种用常量表达式替换全局标识符的方法。这可以是一种在构建之间更改某些代码的行为而不更改代码本身的方法：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#82AAFF;">echo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hooks = DEBUG &amp;&amp; require(&quot;hooks&quot;)</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--define:DEBUG=true</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 结果=&gt; hooks = require(&quot;hooks&quot;);</span></span>
<span class="line"><span style="color:#82AAFF;">echo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hooks = DEBUG &amp;&amp; require(&quot;hooks&quot;)</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--define:DEBUG=false</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 结果=&gt; hooks = false;</span></span>
<span class="line"></span></code></pre></div><p>替换的表达式必须是<code>JSON</code>对象（<code>null、boolean、number、string、array或object</code>）或单个标识符。数组和对象以外的表达式替换是被内联替换的，这意味着它们可以参与常量折叠<code>constant folding</code>。数组和对象替换则是存储在变量中，然后使用标识符引用，而不是内联替换，这避免了替换值的重复副本，但意味着值不参与常量折叠。</p><p>如果要用字符串文字替换某个内容，请记住传递给esbuild的替换值本身必须包含引号。省略引号表示替换值是标识符：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#82AAFF;">echo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">id, str</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--define:id=text</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--define:str=</span><span style="color:#A6ACCD;">\\&quot;</span><span style="color:#C3E88D;">text</span><span style="color:#A6ACCD;">\\&quot;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 结果=&gt; text, &quot;text&quot;;</span></span>
<span class="line"></span></code></pre></div><p>如果您使用的是CLI，请记住，不同的shell对于如何转义双引号字符有不同的规则（当替换值为字符串时，这是必要的）。使用<code>\\“</code>反斜杠转义，因为它在<code>bash</code>和<code>Windows</code>命令提示符中都有效。其他在<code>bash</code>中有效的双引号转义方法（如用单引号包围它们）在<code>Windows</code>上不起作用，因为<code>Windows</code>命令提示符不会删除单引号。这在从<code>package.json</code>文件中的<code>npm脚本</code>使用<code>CLI</code>时很重要，大家都希望该脚本在所有平台上都能使用:</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">scripts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">build</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">esbuild --define:p<wbr>rocess.env.NODE_ENV=</span><span style="color:#A6ACCD;">\\\\\\&quot;</span><span style="color:#C3E88D;">production</span><span style="color:#A6ACCD;">\\\\\\&quot;</span><span style="color:#C3E88D;"> app.js</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>如果您仍然遇到不同<code>shell</code>的跨平台引号转义问题，您可能希望改用<code>JavaScriptAPI</code>。这样的话，您就可以使用常规JavaScript语法来消除跨平台的差异。</p><h3 id="入口点-entry-points" tabindex="-1">入口点 Entry points <a class="header-anchor" href="#入口点-entry-points" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>入口是一个文件数组，每个文件都用作打包算法的输入。它们被称为“入口点”，是因为每一个入口都被当做<code>初始脚本</code>来执行，然后加载它所包含的所有其他代码。您可以使用<code>import</code>语句将它们导入到您的入口点（或导入另一个文件，然后导入到您的入口），而不是在页面中加载带有<code>＜script＞</code>标记的许多库。</p><p>简单的应用程序只需要一个入口点，但如果存在多个逻辑上独立的代码组（如主线程和工作线程），或者应用程序具有独立的模块（如登录页、编辑器页和设置页），则额外的入口点可能很有用。单独的入口点有助于引入关注点分离，并有助于减少浏览器需要下载的不必要代码量。如果应用程序支持的话，启用代码拆分<code>code splitting</code>可以在浏览到第二页时进一步减小下载大小，第二页的入口点与已经访问的第一页共享一些已经下载的代码。</p><p>指定入口点的简单方法是只传递文件路径数组：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild home.ts settings.ts </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">outdir</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">out</span></span>
<span class="line"></span></code></pre></div><p>这将生成两个输出文件<code>out/home.js</code>和<code>out/settings.js</code>，对应于两个入口点<code>home.ts</code>和<code>settings.ts</code>。</p><p>为了进一步控制如何从相应的入口点，打包后其对应的输出文件路径，您应该查看以下选项：</p><ul><li><code>Entry names</code></li><li><code>Out extension</code></li><li><code>Outbase</code></li><li><code>Outdir</code></li><li><code>Outfile</code></li></ul><p>此外，还可以使用其他入口点语法为每个入口点指定完全自定义的打包输出路径：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild out1</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">home.ts out2</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">settings.ts </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">outdir</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">out</span></span>
<span class="line"></span></code></pre></div><p>这将生成两个输出文件<code>out/out1.js</code>和<code>out/out2.js</code>，对应于两个入口点<code>home.ts</code>和<code>settings.ts</code>。</p><h3 id="外部包-external" tabindex="-1">外部包 External <a class="header-anchor" href="#外部包-external" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>可以将文件或包标记为外部，以将其从构建任务中排除。导入不会被打包，而是被保留（对<code>iife</code>和<code>cjs</code>格式使用<code>require</code>，对<code>esm</code>格式使用<code>import</code>），并将在运行时被执行。</p><p>这个配置有几个用途。首先，它可以用于从打包文件中删除不必要的代码，这些代码是您知道的，永远不会执行的代码。例如，一个<code>package</code>可能包含仅能在<code>nodejs</code>中运行的代码，但您的目标环境是浏览器。它还可以用于在运行时从无法打包的包中导入<code>nodejs</code>代码。例如，<code>fsevents</code>包含<code>esbuild</code>不支持的本机扩展。将某物标记为外部包的示例如下：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#82AAFF;">echo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">require(&quot;fsevents&quot;)</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">app.js</span></span>
<span class="line"><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">app.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--bundle</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--external:fsevents</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--platform=node</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 输出=&gt; app.js</span></span>
<span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">fsevents</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>您还可以在外部路径中使用<code>*</code>通配符，将匹配该模式的所有文件标记为外部文件。例如，可以使用<code>*.png</code>删除所有<code>.png</code>文件，或使用<code>/images/*</code>删除以<code>/images/</code>开头的所有路径：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#FFCB6B;">esbuild</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">app.js</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--bundle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">--external:*.png</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">--external:/images/*</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><p>外部路径在路径解析之前和之后都会应用，这使您可以根据源代码中的导入路径和绝对文件系统路径进行匹配。如果外部路径在下面两种情况下都匹配，则该路径被视为外部路径。具体行为如下：</p><ul><li>在路径解析开始之前，将对所有外部路径<code>external</code>和导入路径进行检查比对。此外，如果外部路径看起来像包路径（即不以<code>/</code>或<code>./</code>或<code>../</code>开头），则会检查导入路径，查看它们是否将该包路径作为路径前缀。</li></ul><p>这意味着<code>--external:@foo/bar</code>与<code>--external:@foo/bar/*</code>表示一个意思，它与导入路径<code>@foo/bar/baz</code>能匹配上。因此，<code>external</code>也将<code>@foo/bar</code>包内的所有路径标记为外部路径。</p><ul><li>在路径解析结束后，将针对所有看起来不像包路径的外部路径（即以<code>/</code>或<code>./</code>或<code>../</code>开头的路径）与解析后的绝对路径进行检查比对。但在检查之前，外部路径将与当前工作目录拼接，然后进行标准化，最终生成绝对路径（即使它包含<code>*</code>通配符）。</li></ul><p>这意味着您可以使用<code>--external:./dir/*</code>将目录<code>dir</code>中的所有内容标记为<code>external</code>。注意，前缀<code>./</code>很重要。如果不做么写，使用<code>--external:dir/*</code>将被视为包路径，在路径解析结束后不会再进行检查比对。</p><h3 id="输出格式-format" tabindex="-1">输出格式 Format <a class="header-anchor" href="#输出格式-format" aria-hidden="true">#</a></h3><p><em>Supported by: Transform | Build</em></p><p>这将设置生成的JavaScript文件的输出格式。目前有三个可能的值可以配置：<code>iife</code>、<code>cjs</code>和<code>esm</code>。当未指定输出格式时，如果启用了打包（按下面这几种方式），esbuild将为您选择输出格式，如果禁用了打包，则<code>esbuild</code>不执行任何格式转换。</p><h4 id="iife" tabindex="-1">iife <a class="header-anchor" href="#iife" aria-hidden="true">#</a></h4><p><code>iife</code>格式表示“立即执行的函数表达式”，旨在在浏览器中运行。将代码包装在函数表达式中可以确保代码中的任何变量不会意外地与全局范围中的变量冲突。如果入口文件需要在浏览器中暴露全局变量，则可以使用<code>全局名称global name</code>来配置该全局变量的名称。当未指定输出格式、启用打包并且<code>platform</code>设置为<code>browser</code>（默认情况下为浏览器）时，<code>iife</code>格式将自动启用。指定<code>iife</code>格式如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;alert(&quot;test&quot;)&#39; | esbuild --format=iife</span></span>
<span class="line"><span style="color:#89DDFF;">(()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=&gt;</span><span style="color:#A6ACCD;"> {</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">alert</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span><span style="color:#89DDFF;">)()</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h4 id="commonjs" tabindex="-1">CommonJS <a class="header-anchor" href="#commonjs" aria-hidden="true">#</a></h4><p><code>cjs</code>格式代表<code>CommonJS</code>，旨在在Node中运行。它假定环境包含<code>exports</code>、<code>require</code>和<code>module</code>。<code>ECMAScript</code>模块语法中具有导出的入口点将被转换为一个模块，每个导出名称的<code>exports</code>上都有一个<code>getter</code>函数。当未指定输出格式、启用打包并将<code>platform</code>设置为<code>node</code>时，<code>cjs</code>格式将自动启用。指定<code>cjs</code>格式如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;export default &quot;test&quot;&#39; | esbuild --format=cjs</span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">var stdin_exports </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> {};</span></span>
<span class="line"><span style="color:#82AAFF;">__export</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">stdin_exports, {</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">default</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=&gt;</span><span style="color:#A6ACCD;"> stdin_default</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">module.exports </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">__toCommonJS</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">stdin_exports</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">var stdin_default </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre></div><h4 id="esm" tabindex="-1">ESM <a class="header-anchor" href="#esm" aria-hidden="true">#</a></h4><p><code>esm</code>格式代表<code>ECMAScript模块</code>。它假定环境支持导入和导出语法。以<code>CommonJS</code>模块语法导出的入口文件将转换为<code>module.exports</code>且只有一个<code>default</code>值的导出。当未指定输出格式、启用打包且<code>platform</code>设置为<code>neutral</code>时，将自动启用<code>esm</code>格式。指定<code>esm</code>格式如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;module.exports = &quot;test&quot;&#39; | esbuild --format=esm</span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">var require_stdin </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">__commonJS</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">&lt;stdin&gt;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">exports, module</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> {</span></span>
<span class="line"><span style="color:#A6ACCD;">    module.exports </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">export </span><span style="color:#C792EA;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require_stdin</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre></div><p>esm格式既可以在浏览器中使用，也可以在<code>node</code>中使用，但必须将其作为模块显式加载。如果从另一个模块导入，则会自动将其视为模块加载。否则：</p><ul><li><p>在浏览器中，可以使用<code>&lt;script src=&quot;file.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code>来加载<code>esm</code>模块。</p></li><li><p>在node中，您可以使用<code>node --experimental-modules file.mjs</code>来加载<code>esm</code>模块。请注意，除非您在<code>package.json</code>文件中配置了<code>&quot;type&quot;：&quot;module&quot;</code>，否则<code>node</code>需要<code>.mjs</code>扩展名才能加载<code>esm</code>模块。可以使用<code>esbuild</code>中的<code>输出扩展名out extension</code>来自定义<code>esbuild</code>生成文件的扩展名。您可以在<a href="https://nodejs.org/api/esm.html" target="_blank" rel="noreferrer">此处</a>阅读有关在<code>node</code>中使用<code>ECMAScript</code>模块的更多信息。</p></li></ul><h3 id="注入-inject" tabindex="-1">注入 Inject <a class="header-anchor" href="#注入-inject" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>此选项允许您自动将全局变量替换为另一个文件的导入。这可能是一个有用的工具，它可以使您无法控制的代码适配新的环境。例如，假设您有一个名为<code>process-shim.js</code>的文件，该文件导出一个变量<code>process</code>：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// process-shim.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> process </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">cwd</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// entry.js</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">cwd</span><span style="color:#A6ACCD;">())</span></span>
<span class="line"></span></code></pre></div><p>这是为了替换<code>node</code>的<code>process.cwd()</code>函数的用法，以防止调用它的包在浏览器中运行时崩溃。您可以使用注入功能将全局标识符<code>process</code>的所有调用的地方替换为对该文件的导入：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild entry.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">inject:./process</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">shim.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">outfile</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">out.js</span></span>
<span class="line"></span></code></pre></div><p>结果如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// out.js</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> process </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#82AAFF;">cwd</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">cwd</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h4 id="将inject与define一起使用" tabindex="-1">将inject与define一起使用 <a class="header-anchor" href="#将inject与define一起使用" aria-hidden="true">#</a></h4><p>您还可以将此功能与<code>define</code>功能相结合，以便对导入内容进行更为针对性的选择。例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// process-shim.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">dummy_process_cwd</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// entry.js</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">cwd</span><span style="color:#A6ACCD;">())</span></span>
<span class="line"></span></code></pre></div><p>您可以使用<code>define</code>特性将<code>process.cwd</code>映射到<code>dummy_process_cwd</code>，然后使用<code>inject</code>特性从<code>process-shim.js</code>注入<code>dummy_proc_cwd</code>：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild entry.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">define:process.cwd</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">dummy_process_cwd </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">inject:./process</span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;">shim.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">outfile</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">out.js</span></span>
<span class="line"></span></code></pre></div><p>这将产生以下输出：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// out.js</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">dummy_process_cwd</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">dummy_process_cwd</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><h4 id="自动导入jsx" tabindex="-1">自动导入JSX <a class="header-anchor" href="#自动导入jsx" aria-hidden="true">#</a></h4><p>您可以使用注入功能自动为<code>JSX</code>表达式提供实现。例如，您可以自动导入<code>react</code>包以提供<code>react.createElement</code>等函数。有关详细信息，请参阅<a href="https://esbuild.github.io/content-types/#auto-import-for-jsx" target="_blank" rel="noreferrer">JSX文档</a>。</p><h4 id="没有导入的注入文件" tabindex="-1">没有导入的注入文件 <a class="header-anchor" href="#没有导入的注入文件" aria-hidden="true">#</a></h4><p>您也可以对没有导出的文件使用此功能。在这种情况下，注入的文件只能在其他文件导入之前出现，就像每个输入文件都包含<code>import &quot;./file.js&quot;</code>一样。由于ECMAScript模块的工作方式，这种注入仍然是“卫生的”，因为不同文件中同名的符号会被重命名，这样它们就不会相互冲突。</p><blockquote><p>译者注：此模块的文档，原文可能有错。 标题为<code>without imports</code>，下面解释为<code>without exports</code>，根据使用来看，应该是<code>without exports</code> 👉<a href="https://esbuild.github.io/api/#injecting-files-without-imports" target="_blank" rel="noreferrer">去看原文</a></p></blockquote><h4 id="有条件地注入文件" tabindex="-1">有条件地注入文件 <a class="header-anchor" href="#有条件地注入文件" aria-hidden="true">#</a></h4><p>如果希望仅在<code>export</code>实际被使用时才有条件地导入文件，则应将注入的文件标记为没有副作用，方法是将其放入包中，并在该包的<code>package.json</code>文件中添加<code>“sideEffects”：false</code>。此设置是<code>Webpack</code>中的一个规定，<code>esbuild</code>中适用于任何导入的文件，而不仅仅是与<code>inject</code>一起使用的文件。</p><h3 id="加载器-loader" tabindex="-1">加载器 Loader <a class="header-anchor" href="#加载器-loader" aria-hidden="true">#</a></h3><p><em>Supported by: Transform | Build</em></p><p>此选项可更改给定输入文件的解析方式。例如，<code>js loader</code>将文件解释为<code>JavaScript</code>，<code>css loader</code>将该文件解释为<code>css</code>。有关所有内置加载器的完整列表，请参阅<a href="./Content-Types.html">内容类型</a>页面。</p><p>为给定的文件类型配置加载器后，允许您使用<code>import</code>语句或<code>require</code>加载该文件类型。例如，将<code>.png</code>文件扩展名配置为使用<code>data URL</code>加载器意味着导入<code>.png</code>文件将为您提供包含该图像内容的数据URL：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> url </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./example.png</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> image </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> Image</span></span>
<span class="line"><span style="color:#A6ACCD;">image</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">src </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> url</span></span>
<span class="line"><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#A6ACCD;">(image)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> svg </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./example.svg</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> doc </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">DOMParser</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parseFromString</span><span style="color:#A6ACCD;">(svg</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">application/xml</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> node </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">importNode</span><span style="color:#A6ACCD;">(doc</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">documentElement</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#A6ACCD;">(node)</span></span>
<span class="line"></span></code></pre></div><p>以上代码可以使用构建API进行打包，如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">loader:.png</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">dataurl </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">loader:.svg</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">text</span></span>
<span class="line"></span></code></pre></div><p>如果使用来自<code>stdin</code>的输入的<code>构建API</code>，则该选项的指定方式不同，因为<code>stdin</code>没有文件扩展名。使用<code>构建API</code>配置一个<code>stdin</code>加载器的示例如下：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">echo </span><span style="color:#676E95;font-style:italic;">&#39;import pkg = require(&quot;./pkg&quot;)&#39; | esbuild --loader=ts --bundle</span></span>
<span class="line"></span></code></pre></div><p>转换API<code>transform</code>只需要一个加载器，因为它不涉及与文件系统的交互，因此不处理文件扩展名。为<code>转换API</code>配置加载器（在本例中为ts加载器）如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;let x: number = 1&#39; | esbuild --loader=ts</span></span>
<span class="line"><span style="color:#C792EA;">let </span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre></div><h3 id="代码压缩-minify" tabindex="-1">代码压缩 Minify <a class="header-anchor" href="#代码压缩-minify" aria-hidden="true">#</a></h3><p><em>Supported by: Transform | Build</em></p><p>启用后，生成的代码将被压缩，而不是漂亮的打印。压缩后的代码功能通常是与非精简代码一样的，但更小，这意味着它下载速度更快，但更难调试。通常，您在生产中需要压缩代码，而不是在开发中。</p><p>在<code>esbuild</code>中启用压缩示例如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">$ echo &#39;fn = obj =&gt; { return obj.x }&#39; | esbuild --minify</span></span>
<span class="line"><span style="color:#A6ACCD;">fn=n=&gt;n.x;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>这个选项结合起来做了三件不同的事情：删除空格，重写语法以使其更紧凑，并重命名局部变量以使其更短。通常，您希望执行所有这些压缩操作，但如果需要，也可以单独启用这些选项：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;fn = obj =&gt; { return obj.x }&#39; | esbuild --minify-whitespace</span></span>
<span class="line"><span style="color:#A6ACCD;">fn</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">=&gt;</span><span style="color:#A6ACCD;">{</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> obj.x};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;fn = obj =&gt; { return obj.x }&#39; | esbuild --minify-identifiers</span></span>
<span class="line"><span style="color:#A6ACCD;">fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">n</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=&gt;</span><span style="color:#A6ACCD;"> {</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> n.x;</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;fn = obj =&gt; { return obj.x }&#39; | esbuild --minify-syntax</span></span>
<span class="line"><span style="color:#A6ACCD;">fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=&gt;</span><span style="color:#A6ACCD;"> obj.x;</span></span>
<span class="line"></span></code></pre></div><p>这些相同的概念也适用于<code>CSS</code>，而不仅限于<code>JavaScript</code>：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;"> echo </span><span style="color:#676E95;font-style:italic;">&#39;div { color: yellow }&#39; | esbuild --loader=css --minify</span></span>
<span class="line"><span style="color:#A6ACCD;">div{color:#ff0}</span></span>
<span class="line"></span></code></pre></div><p><code>esbuild</code>中的<code>JavaScript</code>压缩算法通常生成的输出非常接近行业标准<code>JavaScript</code>压缩工具的输出大小。<a href="https://github.com/privatenumber/minification-benchmarks/tree/cd3e5acb8d38da5f86426d44ac95974812559683#readme" target="_blank" rel="noreferrer">这里</a>有一个不同压缩工具之间输出大小的示例比较。虽然<code>esbuild</code>在所有情况下都不是最佳的<code>JavaScript</code>压缩工具（也不是试图做到这一点），但它努力在大多数代码专业压缩工具百分之几之内的大小，当然也比其他工具快得多。</p><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-hidden="true">#</a></h4><p>使用<code>esbuild</code>作为压缩工具时，以下是要记住的一些事项：</p><ul><li><p>当启用缩小时，您可能还应该设置目标选项<code>target</code>。默认情况下，<code>esbuild</code>利用现代<code>JavaScript</code>特性使代码更小。例如，<code>a === undefined || a === null ? 1 : a</code>可以缩小为<code>a ?? 1</code>。如果不希望<code>esbuild</code>在缩小时利用现代<code>JavaScript</code>功能，则应使用较旧的语言目标<code>target</code>，例如<code>--target=es6</code>。</p></li><li><p>字符转义序列<code>\\n</code>将替换为<code>JavaScript</code>模板文本中的换行符。如果<code>target</code>支持字符串文字，则字符串文字也将转换为模板文字，因为这样做将获得较小的输出。这不是一个bug。压缩意味着您需要更小的输出，转义序列需要两个字节，而换行符只需要一个字节。</p></li><li><p>默认情况下，<code>esbuild</code>不会缩小顶级声明的名称。这是因为<code>esbuild</code>不知道您将如何处理这些输出。您可能正在将压缩后的代码注入到其他代码的中间，在这种情况下，压缩顶级声明的名称是不安全的。设置输出格式<code>format</code>（或启用打包，如果尚未设置输出格式，启用打包后会为您自动选择）会告诉<code>esbuild</code>输出将在其自身范围内运行，这意味着可以安全地压缩顶级声明的名称。</p></li><li><p>对于所有JavaScript代码的可以100%的说，代码压缩是不安全的。这对于<code>esbuild</code>以及其他流行的<code>JavaScript</code>压缩插件（如<code>terser</code>）都是如此。特别是，<code>esbuild</code>的设计不会保留函数调用<code>.toString()</code>后的值。这样做的原因是，所有函数中的所有代码都必须逐字保留，那么压缩几乎不会有任何作用，而且实际上是无用的。然而，这意味着依赖<code>.toString()</code>返回值的<code>JavaScript</code>代码在压缩时可能会中断。例如，由于<code>AngularJS</code>使用了<code>.toString()</code>读取函数的参数名，所以当代码被压缩时，<code>AngularJS</code>框架中的某些模式会中断。解决方法是改用显式注释<code>explicit annotations</code>。</p></li><li><p>默认情况下，<code>esbuild</code>不会在函数和类对象上保留<code>.name</code>的值。这是因为大多数代码不依赖此属性，使用较短的名称是一个重要的大小优化。但是，有些代码确实依赖<code>.name</code>属性进行注册和绑定。如果需要依赖此选项，则应启用保留名称选项<code>keep names</code>。</p></li><li><p>使用某些<code>JavaScript</code>功能可以禁用<code>esbuild</code>的许多优化，包括代码压缩。具体来说，使用直接<code>eval</code>或<code>with语句</code>可以防止<code>esbuild</code>将标识符重命名为较小的名称，因为这些特性会让标识符打包到运行时而不是编译时。这虽然总是无意发生的，因为人们没察觉到直接调用<code>evel</code>计算了什么，以及为什么它不好。</p></li></ul><p>如果您正在考虑编写这样的代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Direct eval (will disable minification for the whole file)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">eval</span><span style="color:#A6ACCD;">(something)</span></span>
<span class="line"></span></code></pre></div><p>您可能应该改为下面这样编写代码，以便可以压缩代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Indirect eval (has no effect on the surrounding code)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> result </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> (</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> eval)(something)</span></span>
<span class="line"></span></code></pre></div><p><a href="https://esbuild.github.io/content-types/#direct-eval" target="_blank" rel="noreferrer">这里</a>有更多关于直接求值的结果和可用替代方案的信息。</p><ul><li><p>esbuild中的压缩算法尚未进行高级优化。特别是，以下对于JavaScript的代码优化是可能的，但esbuild还尚未完成（不是详细的列表）：</p></li><li><p>Dead-code elimination within function bodies</p></li><li><p>Function inlining</p></li><li><p>Cross-statement constant propagation</p></li><li><p>Object shape modeling</p></li><li><p>Allocation sinking</p></li><li><p>Method devirtualization</p></li><li><p>Symbolic execution</p></li><li><p>JSX expression hoisting</p></li><li><p>TypeScript enum detection and inlining</p></li></ul><p>如果您的代码使用的模式需要某些形式的代码优化才能打包，或者如果您正在为您的用例搜索最佳的JavaScript压缩算法，则应考虑使用其他工具。一些实现了这些高级代码优化的工具示例包括<code>Terser</code>和<code>Google Closure Compiler</code>。</p><h3 id="输出目录-outdir" tabindex="-1">输出目录 Outdir <a class="header-anchor" href="#输出目录-outdir" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>此选项设置生成文件的输出目录。例如，下面命令将生成一个名为out的目录：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">outdir</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">out</span></span>
<span class="line"></span></code></pre></div><p>如果输出目录不存在，将创建该目录，如果它已经包含了一些文件，则不会清空该目录。任何生成的文件都将自动覆盖同名的现有文件。如果希望输出目录仅包含当前运行的<code>esbuild</code>输出的文件，则应在运行<code>esbuild</code>之前自行清空输出目录。</p><p>如果您的构建在不同的目录中包含多个入口点，则目录结构将从所有输入入口点路径中最低的公共祖先目录<code>lowest common ancestor</code>开始复制到输出目录中。例如，如果有两个入口点<code>src/home/index.ts</code>和<code>src/about/index.ts</code>，则输出目录将包含<code>home/index.js</code>和<code>about/index.js</code>。如果要自定义此行为，应更改配置<code>outbase directory</code>。</p><h3 id="输出文件-outfile" tabindex="-1">输出文件 Outfile <a class="header-anchor" href="#输出文件-outfile" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>此选项设置构建后的输出文件名。这仅适用于只有一个入口点的情况。如果有多个入口点，则必须使用<code>outdir</code>选项来指定输出目录。使用<code>outfile</code>如下所示：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">outfile</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">out.js</span></span>
<span class="line"></span></code></pre></div><h3 id="依赖包-packages" tabindex="-1">依赖包 Packages <a class="header-anchor" href="#依赖包-packages" aria-hidden="true">#</a></h3><p><em>Supported by: Build</em></p><p>使用此设置可以从打包文件中排除包的所有依赖项。这在打包<code>node</code>时非常有用，因为许多<code>npm</code>包使用了<code>node</code>特定的功能，但<code>esbuild</code>在打包时是不支持（例如<code>__dirname</code>、<code>i<wbr>mport.meta.url</code>、<code>fs.readFileSync</code>和<code>*.node</code>本机二进制模块）。使用这个配置看起来像这样：</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.js </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">bundle </span><span style="color:#89DDFF;">--</span><span style="color:#A6ACCD;">packages</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">external</span></span>
<span class="line"></span></code></pre></div><p>启用此选项会自动将所有看起来像<code>npm</code>包的导入路径（即不以<code>.</code>或<code>..</code>路径开头且不是绝对路径）标记为外部路径。它与手动将每个依赖项传递到<code>external</code>选项具有相同的效果，但更简洁。如果要自定义哪些依赖项是外部的，哪些不是外部的，那么应该使用<code>external</code>进行设置。</p><p>请注意，此设置仅在启用打包时有效。还请注意，将导入路径标记为外部路径发生在导入路径被所有配置的别名<code>aliases</code>重写之后，因此使用此设置时，别名功能<code>aliases</code>仍然有效。</p><h3 id="平台-platform" tabindex="-1">平台 Platform <a class="header-anchor" href="#平台-platform" aria-hidden="true">#</a></h3><p><em>Supported by: Transform | Build</em></p><p>默认情况下，esbuild的bundler被配置为生成用于浏览器的代码。如果打包代码打算在<code>node</code>中运行，则应将平台设置为<code>node</code>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">esbuild app.js --bundle --platform=node</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>当平台设置为浏览器<code>broswer</code>（默认值）时：</p><ul><li><p>启用打包时，默认输出格式设置为<code>iife</code>，它将生成的<code>JavaScript</code>代码包裹在一个立即执行的函数表达式中，以防止变量泄漏到全局范围中。</p></li><li><p>如果一个包在其<code>package.json</code>文件中为<code>browser</code>字段指定了映射，<code>esbuild</code>将使用该映射以浏览器友好的版本替换特定的文件或模块。例如，一个包可能使用<code>path-browserify</code>替换<code>path</code>。</p></li><li><p><code>main</code>字段可设置为<code>browser</code>、<code>module</code>、<code>main</code>，有一些额外的特殊行为：如果包提供了<code>module</code>和<code>main</code>入口点，但不是<code>browser</code>入口点，则如果使用<code>require()</code>导入包，则使用<code>main</code>而不是<code>module</code>。这种方式提高了导出函数与<code>CommonJS</code>模块（通过将函数分配给<code>module.exports</code>）的兼容性。如果要禁用此额外的特殊行为，可以将<code>main</code>字段显式设置为<code>browser、module、main</code>。</p></li></ul><p>todo...</p>`,204),p=[e];function c(t,r,d,i,y,C){return n(),a("div",null,p)}const F=s(l,[["render",c]]);export{A as __pageData,F as default};
